<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>カレンダーアノテーター</title>
  <style>
    /* 全体のスタイル */
    :root {
      --primary-color: #007bff;
      --border-color: #e0e0e0;
      --bg-light: #f4f7f9;
      --bg-white: #ffffff;
      --text-primary: #333;
      --text-secondary: #888;
      --text-sunday: #d9534f;
      --text-saturday: #428bca;
      --label-bg-default: #fffbe6;
      --popover-bg: #fff;
      --popover-shadow: rgba(0, 0, 0, 0.15);
      --danger-color: #dc3545;

      /* New button colors */
      --btn-blue-bg: #eaf4ff;
      --btn-blue-hover-bg: #d0e6ff;
      --btn-yellow-bg: #fff9e0;
      --btn-yellow-hover-bg: #fff2c2;
      --btn-brown-bg: #f4f0eb;
      --btn-brown-hover-bg: #e8e2d9;
      --btn-green-bg: #e6f8e6;
      --btn-green-hover-bg: #d1f0d1;
      --btn-red-bg: #ffebeb;
      --btn-red-hover-bg: #ffd6d6;
      --btn-purple-bg: #f3e8ff;
      --btn-purple-hover-bg: #e9d5ff;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      background-color: var(--bg-light);
      color: var(--text-primary);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    #root {
      display: flex;
      justify-content: center;
      padding: 20px;
    }
    .app-container {
      width: 100%;
      max-width: 1200px;
      min-width: 800px;
      background-color: var(--bg-white);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* ヘッダー */
    .header {
      padding: 16px 24px;
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
    }
    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 20px;
    }
    .header-controls {
        display: flex;
        align-items: center;
        gap: 16px;
        width: 100%;
    }
    .id-control {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .id-control label {
        font-size: 1em;
        font-weight: 500;
        color: #555;
        white-space: nowrap;
    }
    .id-control input {
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 0.9em;
        min-width: 200px;
    }
    .data-ops {
        margin-left: auto; /* 右寄せ */
        display: flex;
        gap: 8px;
    }
    .data-ops button {
      background-color: var(--bg-white);
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.2s ease-in-out;
      white-space: nowrap;
    }
    .data-ops button:hover {
      background-color: #f0f0f0;
      border-color: #bbb;
      transform: translateY(-1px);
    }
     .data-ops button:active {
      background-color: #e0e0e0;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
      transform: translateY(0);
    }
    
    /* Date Picker Popover */
    .date-picker-container {
      position: relative;
    }
    .header-title-btn {
      background-color: transparent;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out;
      font-size: 1.5em;
      font-weight: 600;
      color: #2c3e50;
      font-family: inherit;
      white-space: nowrap;
    }
    .header-title-btn:hover {
      background-color: #f0f0f0;
    }
    #date-picker-popover {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      width: 280px;
      background-color: var(--popover-bg);
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      padding: 16px;
      z-index: 200;
      border: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .date-picker-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .date-picker-header button {
      background: none;
      border: none;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      padding: 4px 12px;
      border-radius: 4px;
    }
    .date-picker-header button:hover {
      background-color: #f0f0f0;
    }
    #year-input {
      width: 80px;
      text-align: center;
      font-size: 1.1em;
      font-weight: 500;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 4px;
      -moz-appearance: textfield; /* Firefox */
    }
    #year-input::-webkit-outer-spin-button,
    #year-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    .month-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    .month-btn {
      padding: 10px;
      border-radius: 6px;
      border: 1px solid transparent;
      background-color: #f8f8f8;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.9em;
    }
    .month-btn:hover {
      background-color: #eef7ff;
      border-color: var(--primary-color);
    }
    .month-btn.active {
      background-color: var(--primary-color);
      color: white;
      font-weight: bold;
    }
    .date-picker-footer {
      text-align: center;
      margin-top: 8px;
    }
    #date-picker-today-btn {
      width: 100%;
      padding: 10px;
      font-size: 1em;
      font-weight: 500;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    #date-picker-today-btn:hover {
      background-color: #e0e0e0;
    }

    /* 装飾バー (削除された要素のスタイルもコメントアウトまたは削除) */
    .deco-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .deco-control label {
      font-size: 13px;
      color: #555;
    }
    .deco-control input[type="color"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 28px;
      height: 28px;
      background-color: transparent;
      border: none;
      cursor: pointer;
      padding: 0;
    }
    .deco-control input[type="color"]::-webkit-color-swatch {
      border-radius: 50%;
      border: 1px solid var(--border-color);
    }
    .deco-control input[type="range"] {
      width: 100px;
    }
    .deco-control .font-size-value {
      font-size: 13px;
      width: 20px;
      text-align: right;
    }
    .style-btn-group button {
      background: var(--bg-white);
      border: 1px solid #ccc;
      font-size: 14px;
      padding: 4px 10px;
      cursor: pointer;
      pointer-events: all; /* クリックイベントを確実に拾う */
    }
    .style-btn-group button:first-child {
      border-radius: 4px 0 0 4px;
      border-right: none;
    }
    .style-btn-group button:last-child {
      border-radius: 0 4px 4px 0;
    }
    .style-btn-group button.active {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }


    /* カレンダーボード */
    .calendar-board {
      padding: 16px;
      flex-grow: 1;
    }
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 1px;
      background-color: var(--border-color);
      border: 1px solid var(--border-color);
      height: 100%;
      user-select: none; /* テキスト選択を防ぐ */
    }
    .day-header {
      text-align: center;
      padding: 10px 0;
      font-weight: 600;
      background-color: #f5f5f5;
    }
    .day-header.sunday { color: var(--text-sunday); }
    .day-header.saturday { color: var(--text-saturday); }

    /* 日付セル */
    .date-cell {
      position: relative;
      min-height: 120px;
      background-color: var(--bg-white);
      padding: 8px;
      transition: background-color 0.2s;
      display: flex;
      flex-direction: column;
      cursor: pointer;
    }
    .date-cell.other-month {
      background-color: #fdfdfd;
    }
    .date-cell.other-month .date-number {
      color: var(--text-secondary);
      opacity: 0.7;
    }
     .date-cell:hover {
        background-color: #eef7ff;
     }
     .date-cell.other-month:hover {
        background-color: #f5fafd;
     }

    .date-number {
      font-size: 0.9em;
      font-weight: 500;
      text-align: left;
      margin-bottom: 4px;
    }
    .date-number.sunday { color: var(--text-sunday); }
    .date-number.saturday { color: var(--text-saturday); }
    .date-number.today {
        background-color: var(--primary-color);
        color: var(--bg-white);
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
    }
    .labels-container {
        flex-grow: 1;
        position: relative;
    }
    
    /* ラベル */
    .label {
      position: absolute;
      background-color: var(--label-bg-default);
      border: 1px solid transparent; /* 枠線を透明に変更 */
      border-radius: 4px;
      padding: 4px 6px;
      font-size: 0.85em;
      cursor: grab;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      z-index: 10;
      min-height: 20px;
      width: calc(100% - 10px); /* 親要素から少し内側に */
      word-wrap: break-word; /* テキストの折り返し */
    }
    .label.editing {
      outline: 2px solid var(--primary-color);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      z-index: 20;
      cursor: text;
    }
    .label[contenteditable="true"]:focus {
      outline: none; /* editingクラスで制御するため */
    }
    .label.dragging {
      opacity: 0.7;
      cursor: grabbing;
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
      z-index: 999;
      width: auto; 
    }

    /* ポップオーバー */
    #popover {
      position: fixed;
      background-color: var(--popover-bg);
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--popover-shadow);
      padding: 0; /* Changed */
      display: flex;
      flex-direction: column; /* Changed */
      z-index: 100;
      border: 1px solid var(--border-color);
      transition: opacity 0.1s ease-in-out, transform 0.1s ease-in-out;
      max-width: 250px;
    }
    .popover-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      font-weight: 500;
      font-size: 14px;
    }
    .popover-header .close-btn {
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      line-height: 1;
      padding: 0 4px;
      color: #888;
    }
    .popover-header .close-btn:hover {
      color: #333;
    }
    .popover-content {
      padding: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .popover-btn {
        border: 1px solid #dcdcdc;
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 13px;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s;
    }
    .popover-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    /* --- Popover Button Colors --- */
    /* 決定 (save/update) / 選択 (select) - Light Blue */
    .popover-btn[data-action="save"],
    .popover-btn[data-action="update"],
    .popover-btn[data-action="select"] {
        background-color: var(--btn-blue-bg);
        border-color: #b8d6f5;
    }
    .popover-btn[data-action="save"]:hover:not(:disabled),
    .popover-btn[data-action="update"]:hover:not(:disabled),
    .popover-btn[data-action="select"]:hover:not(:disabled) {
        background-color: var(--btn-blue-hover-bg);
    }

    /* 貼付 (paste) / 複写 (duplicate) - Light Yellow */
    .popover-btn[data-action="paste"],
    .popover-btn[data-action="duplicate"] {
        background-color: var(--btn-yellow-bg);
        border-color: #f0e0a4;
    }
    .popover-btn[data-action="paste"]:hover:not(:disabled),
    .popover-btn[data-action="duplicate"]:hover:not(:disabled) {
        background-color: var(--btn-yellow-hover-bg);
    }
    
    /* 呼出 (recall) - Light Brown */
    .popover-btn[data-action="recall"] {
        background-color: var(--btn-brown-bg);
        border-color: #dcd4c9;
    }
    .popover-btn[data-action="recall"]:hover:not(:disabled) {
        background-color: var(--btn-brown-hover-bg);
    }

    /* 取消 (cancel) / 閉じる (close) - Light Red */
    .popover-btn[data-action="cancel"],
    .popover-btn[data-action="close"] {
        background-color: var(--btn-red-bg);
        border-color: #f5c4c4;
    }
    .popover-btn[data-action="cancel"]:hover:not(:disabled),
    .popover-btn[data-action="close"]:hover:not(:disabled) {
        background-color: var(--btn-red-hover-bg);
    }
    
    /* 装飾 (decorate) - Light Purple */
    .popover-btn[data-action="decorate"] {
        background-color: var(--btn-purple-bg);
        border-color: #d3b3ff;
    }
    .popover-btn[data-action="decorate"]:hover:not(:disabled) {
        background-color: var(--btn-purple-hover-bg);
    }

    /* テンプレ保存 (save-template) - Light Green */
    .popover-btn[data-action="save-template"] {
        background-color: var(--btn-green-bg);
        border-color: #b8e2b8;
    }
    .popover-btn[data-action="save-template"]:hover:not(:disabled) {
        background-color: var(--btn-green-hover-bg);
    }

    /* 削除 (delete) - White bg, black border, red text */
    .popover-btn[data-action="delete"] {
        background-color: #ffffff;
        color: var(--danger-color);
        border: 1px solid #333;
        font-weight: 500;
    }
    .popover-btn[data-action="delete"]:hover:not(:disabled) {
        background-color: var(--danger-color);
        color: white;
        border-color: var(--danger-color);
    }

    /* Decoration Popover */
    #decoration-popover {
      position: fixed;
      background-color: var(--popover-bg);
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--popover-shadow);
      padding: 12px;
      z-index: 101; /* Above main popover */
      border: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 280px;
    }
    .deco-popover-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 500;
      font-size: 14px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-color);
    }
    .deco-popover-header button {
        background: none;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        line-height: 1;
        padding: 0 4px;
        color: #888;
    }
    .deco-popover-header button:hover {
        color: #333;
    }
    .deco-popover-controls {
        display: flex;
        flex-direction: column;
        gap: 16px;
    }
    .deco-popover-controls .deco-control {
        gap: 12px;
    }
    .deco-popover-controls .deco-control label {
        flex-basis: 70px;
        flex-shrink: 0;
    }
    .deco-popover-controls .deco-control input[type="range"] {
        flex-grow: 1;
    }
    .deco-popover-controls .style-btn-group {
        margin-left: auto;
    }
    
    /* テンプレートポップオーバー */
    .template-popover-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .template-popover-modal {
        background-color: var(--popover-bg);
        border-radius: 8px;
        padding: 8px;
        width: 90%;
        max-width: 250px;
        box-shadow: 0 4px 12px var(--popover-shadow);
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 80vh;
    }
    .template-list {
        list-style: none;
        padding: 0;
        margin: 0;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        max-height: 250px;
    }
    .template-list-item {
        padding: 10px;
        border-bottom: 1px solid #f0f0f0;
        cursor: pointer;
        transition: background-color 0.2s;
        word-wrap: break-word;
    }
    .template-list-item:last-child {
        border-bottom: none;
    }
    .template-list-item:hover {
        background-color: #f5f5f5;
    }
    .template-list-item.selected {
        background-color: #eef7ff;
        border-left: 3px solid var(--primary-color);
        font-weight: 500;
    }
    .template-list-placeholder {
        padding: 20px;
        text-align: center;
        color: #888;
    }
    .template-popover-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
    }
  </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
  <div id="root"></div>
  <div id="popover" style="display: none;"></div>
  <div id="decoration-popover" style="display: none;"></div>
  <div id="template-popover-container"></div>
  <input type="file" id="file-importer" accept=".json" style="display: none;">

  <script type="module">
    // --- アプリケーションの状態 ---
    let currentDate = new Date();
    // ラベルデータ構造: { id, date, text, top, left, style: { color, backgroundColor, fontSize, fontWeight, fontStyle } }
    let labels = []; 
    // テンプレートデータ構造: { id, text, style: { ... } }
    let templates = [];
    let currentId = '';
    let activeLabelInfo = null; // { type, id?, date?, text?, top?, left?, style? }
    let clipboard = null; // { text, style }
    let dragInfo = null; // { id, element, offsetX, offsetY, hasMoved, startX, startY }
    let defaultStyle = {
        color: '#333333',
        backgroundColor: '#fffbe6',
        fontSize: '13',
        fontWeight: 'normal',
        fontStyle: 'normal',
    };
    let isDatePickerVisible = false;
    let datePickerYear = new Date().getFullYear();
    let isTemplatePopoverVisible = false;
    let selectedTemplateId = null;
    let isDecorationPopoverVisible = false;
    let isWheeling = false; // For wheel throttling

    const LOCAL_STORAGE_KEY = 'calendar-annotator-data';

    // --- DOM要素 ---
    const root = document.getElementById('root');
    const popover = document.getElementById('popover');
    const decorationPopover = document.getElementById('decoration-popover');
    const templatePopoverContainer = document.getElementById('template-popover-container');

    // --- Data Persistence ---
    const saveDataToLocalStorage = () => {
        try {
            const data = { labels, templates, currentId };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
        } catch (e) {
            console.error("Failed to save data to localStorage:", e);
        }
    };
    
    const loadDataFromLocalStorage = () => {
        try {
            const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                labels = parsedData.labels || [];
                templates = parsedData.templates || [];
                currentId = parsedData.currentId || '';
            }
        } catch (e) {
            console.error("Failed to load or parse data from localStorage:", e);
            labels = [];
            templates = [];
            currentId = '';
        }
    };

    // --- Helper Functions ---
    const formatDate = (date) => {
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, '0');
        const d = String(date.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
    }
    
    const getLabelStyle = (styleObj) => {
        if (!styleObj) return '';
        return `
            color: ${styleObj.color}; 
            background-color: ${styleObj.backgroundColor}; 
            font-size: ${styleObj.fontSize}px; 
            font-weight: ${styleObj.fontWeight}; 
            font-style: ${styleObj.fontStyle};
        `;
    }

    // --- Popover Functions ---
    const showPopover = (targetElement) => {
        if (!activeLabelInfo) return;

        let buttonsHtml = '';
        const pasteButtonDisabled = !clipboard ? 'disabled' : '';
        const popoverTitle = activeLabelInfo.type === 'new' ? '新規ラベル' : 'ラベル編集';

        if (activeLabelInfo.type === 'new') {
            buttonsHtml = `
                <button class="popover-btn" data-action="save">決定</button>
                <button class="popover-btn" data-action="paste" ${pasteButtonDisabled}>貼付</button>
                <button class="popover-btn" data-action="recall">呼出</button>
                <button class="popover-btn" data-action="decorate">装飾</button>
            `;
        } else { // 'existing'
            buttonsHtml = `
                <button class="popover-btn" data-action="update">決定</button>
                <button class="popover-btn" data-action="duplicate">複写</button>
                <button class="popover-btn" data-action="decorate">装飾</button>
                <button class="popover-btn" data-action="save-template">テンプレ保存</button>
                <button class="popover-btn" data-action="delete">削除</button>
            `;
        }

        const popoverHtml = `
            <div class="popover-header">
                <span>${popoverTitle}</span>
                <button class="close-btn" data-action="close" aria-label="閉じる">&times;</button>
            </div>
            <div class="popover-content">
                ${buttonsHtml}
            </div>
        `;
        popover.innerHTML = popoverHtml;
        popover.style.display = 'flex';
        
        // --- ポップオーバー位置決めロジック ---
        const calendarBoard = document.getElementById('calendar-board');
        const calendarGrid = document.getElementById('calendar-grid');
        if (!calendarBoard || !calendarGrid) return; 

        const boardRect = calendarBoard.getBoundingClientRect();
        const gridRect = calendarGrid.getBoundingClientRect();
        const rect = targetElement.getBoundingClientRect();
        const popoverWidth = popover.offsetWidth;
        const popoverHeight = popover.offsetHeight;
        const margin = 8;
        
        let popoverTop, popoverLeft;
        
        // 水平位置を計算（中央揃えを基本にしつつ、カレンダーの中心に寄せる）
        const gridCenterX = gridRect.left + gridRect.width / 2;
        const targetCenterX = rect.left + rect.width / 2;
        const horizontalOffset = 40; // 中央に寄せるオフセット

        popoverLeft = targetCenterX - (popoverWidth / 2); // 基本の中央揃え

        if (targetCenterX < gridCenterX) {
            popoverLeft += horizontalOffset; // 左側なので右にずらす
        } else {
            popoverLeft -= horizontalOffset; // 右側なので左にずらす
        }
        
        // 画面からはみ出ないように水平位置を調整
        if (popoverLeft < 10) {
            popoverLeft = 10;
        } else if (popoverLeft + popoverWidth > window.innerWidth - 10) {
            popoverLeft = window.innerWidth - popoverWidth - 10;
        }
        
        // 垂直位置を計算 (カレンダー領域を基準にする)
        const spaceAbove = rect.top - boardRect.top;
        const spaceBelow = boardRect.bottom - rect.bottom;
        const popoverFitsBelow = spaceBelow > popoverHeight + margin;
        const popoverFitsAbove = spaceAbove > popoverHeight + margin;

        if (popoverFitsBelow && (!popoverFitsAbove || spaceBelow > spaceAbove)) {
            // 下に表示
            popoverTop = rect.bottom + margin;
        } else {
            // 上に表示
            popoverTop = rect.top - popoverHeight - margin;
        }
        
        // 画面からはみ出ないように垂直位置を再調整
        if (popoverTop < 10) {
            popoverTop = 10;
        } else if (popoverTop + popoverHeight > window.innerHeight - 10) {
            popoverTop = window.innerHeight - popoverHeight - 10;
        }

        popover.style.top = `${popoverTop}px`;
        popover.style.left = `${popoverLeft}px`;
    };

    const hidePopover = () => {
        if(activeLabelInfo) {
            activeLabelInfo = null;
            render();
        }
        popover.style.display = 'none';
        hideDecorationPopover();
    };

    const handleDecorationPopoverClick = (e) => {
        const target = e.target;
        if (target.closest('[data-style]')) {
            handleDecorationChange(e);
        } else if (target.closest('[data-action="close-deco"]')) {
            hideDecorationPopover();
        }
    };

    // --- Decoration Popover Functions ---
    const showDecorationPopover = () => {
        if (!activeLabelInfo) return;

        const currentStyle = activeLabelInfo.style;
        const popoverHtml = `
            <div class="deco-popover-header">
                <span>装飾</span>
                <button data-action="close-deco" aria-label="閉じる">&times;</button>
            </div>
            <div class="deco-popover-controls">
                <div class="deco-control">
                    <label for="deco-text-color">文字色</label>
                    <input type="color" id="deco-text-color" data-style="color" data-css-prop="color" value="${currentStyle.color}">
                </div>
                <div class="deco-control">
                    <label for="deco-label-color">ラベル色</label>
                    <input type="color" id="deco-label-color" data-style="backgroundColor" data-css-prop="backgroundColor" value="${currentStyle.backgroundColor}">
                </div>
                <div class="deco-control">
                    <label for="deco-font-size">大きさ</label>
                    <input type="range" id="deco-font-size" min="10" max="24" step="1" data-style="fontSize" data-css-prop="fontSize" value="${currentStyle.fontSize}">
                    <span id="deco-font-size-value" class="font-size-value">${currentStyle.fontSize}</span>
                </div>
                <div class="deco-control">
                    <label>スタイル</label>
                    <div class="style-btn-group">
                        <button id="deco-bold-btn" data-style="fontWeight" data-css-prop="fontWeight" class="${currentStyle.fontWeight === 'bold' ? 'active' : ''}"><b>B</b></button>
                        <button id="deco-italic-btn" data-style="fontStyle" data-css-prop="fontStyle" class="${currentStyle.fontStyle === 'italic' ? 'active' : ''}"><i>I</i></button>
                    </div>
                </div>
            </div>
        `;
        decorationPopover.innerHTML = popoverHtml;
        decorationPopover.style.display = 'flex';
        isDecorationPopoverVisible = true;

        // --- 位置決めロジック ---
        const calendarGrid = document.getElementById('calendar-grid');
        const activeLabelEl = document.querySelector('.label.editing');
        if (!calendarGrid || !activeLabelEl) return;

        const gridRect = calendarGrid.getBoundingClientRect();
        const gridCenterX = gridRect.left + gridRect.width / 2;
        
        const mainPopoverRect = popover.getBoundingClientRect();
        const activeLabelRect = activeLabelEl.getBoundingClientRect();
        const decoPopoverWidth = decorationPopover.offsetWidth;
        const decoPopoverHeight = decorationPopover.offsetHeight;
        
        let decoTop, decoLeft;
        
        // 水平位置の決定 (カレンダー中央側に寄せる)
        const mainPopoverCenterX = mainPopoverRect.left + mainPopoverRect.width / 2;
        if (mainPopoverCenterX < gridCenterX) {
            // メインポップオーバーが左側 -> 装飾パネルは右側にずらして重ねる
            decoLeft = mainPopoverRect.right - (decoPopoverWidth / 3);
        } else {
            // メインポップオーバーが右側 -> 装飾パネルは左側にずらして重ねる
            decoLeft = mainPopoverRect.left - (decoPopoverWidth * 2 / 3);
        }

        // 垂直位置の決定 (メインポップオーバーの位置に連動)
        const isPopoverAboveLabel = mainPopoverRect.top < activeLabelRect.top;
        if (isPopoverAboveLabel) {
            // メインがラベルの上にある場合、装飾パネルはさらに上に表示
            // 装飾パネルの下辺がメインの上辺から少し見えるくらいの位置
            decoTop = mainPopoverRect.top - decoPopoverHeight + 30;
        } else {
            // メインがラベルの下にある場合、装飾パネルはさらに下に表示
            // 装飾パネルの上辺がメインの下辺から少し見えるくらいの位置
            decoTop = mainPopoverRect.bottom - 30;
        }
        
        // 画面からはみ出ないように最終調整
        if (decoLeft < 10) {
            decoLeft = 10;
        } else if (decoLeft + decoPopoverWidth > window.innerWidth - 10) {
            decoLeft = window.innerWidth - decoPopoverWidth - 10;
        }
        if (decoTop < 10) {
            decoTop = 10;
        } else if (decoTop + decoPopoverHeight > window.innerHeight - 10) {
            decoTop = window.innerHeight - decoPopoverHeight - 10;
        }
        
        decorationPopover.style.top = `${decoTop}px`;
        decorationPopover.style.left = `${decoLeft}px`;

        decorationPopover.removeEventListener('input', handleDecorationChange);
        decorationPopover.removeEventListener('click', handleDecorationPopoverClick);
        decorationPopover.addEventListener('input', handleDecorationChange);
        decorationPopover.addEventListener('click', handleDecorationPopoverClick);
    };
    
    const hideDecorationPopover = () => {
        decorationPopover.style.display = 'none';
        isDecorationPopoverVisible = false;
    };

    const handleDecorationChange = (e) => {
        const target = e.target.closest('[data-style]');
        if (!target || !activeLabelInfo) return;

        const styleProp = target.dataset.style;
        let value = target.value;
        const isToggleButton = target.tagName === 'BUTTON';

        if (isToggleButton) {
            const currentVal = activeLabelInfo.style[styleProp];
            if (styleProp === 'fontWeight') value = currentVal === 'bold' ? 'normal' : 'bold';
            if (styleProp === 'fontStyle') value = currentVal === 'italic' ? 'normal' : 'italic';
            target.classList.toggle('active');
        }

        activeLabelInfo.style[styleProp] = value;

        const activeLabelEl = document.querySelector('.label.editing');
        if (activeLabelEl) {
             if(styleProp === 'fontSize') {
                activeLabelEl.style.fontSize = `${value}px`;
                document.getElementById('deco-font-size-value').textContent = value;
            } else if (['fontWeight', 'fontStyle', 'color', 'backgroundColor'].includes(styleProp)) {
                activeLabelEl.style[target.dataset.cssProp] = value;
            }
        }
    };


    // --- イベントハンドラ ---
    const toggleDatePicker = () => {
        isDatePickerVisible = !isDatePickerVisible;
        if (isDatePickerVisible) {
            datePickerYear = currentDate.getFullYear();
        }
        render();
    };

    const handleDatePickerClick = (e) => {
        const target = e.target;
        const monthBtn = target.closest('.month-btn');
        
        if (target.closest('#prev-year-btn')) {
            datePickerYear--;
            render();
        } else if (target.closest('#next-year-btn')) {
            datePickerYear++;
            render();
        } else if (monthBtn) {
            const month = monthBtn.dataset.month;
            currentDate = new Date(datePickerYear, parseInt(month, 10), 1);
            isDatePickerVisible = false;
            render();
        } else if (target.closest('#date-picker-today-btn')) {
            currentDate = new Date();
            isDatePickerVisible = false;
            render();
        }
    };
    
    const handleYearInputChange = (e) => {
        const year = parseInt(e.target.value, 10);
        if (!isNaN(year) && String(year).length >= 4) {
             datePickerYear = year;
             render();
        }
    };
    
    const handleCalendarClick = (e) => {
        if (dragInfo && dragInfo.hasMoved) return;

        const clickedLabelEl = e.target.closest('.label');
        const clickedCellEl = e.target.closest('.date-cell');

        if (e.target.closest('#popover') || e.target.closest('#decoration-popover') || e.target.closest('.date-picker-container') || e.target.closest('.template-popover-backdrop')) {
            return;
        }
        
        if (clickedCellEl && clickedCellEl.classList.contains('other-month')) {
            const dateStr = clickedCellEl.dataset.date;
            const [year, month, day] = dateStr.split('-').map(Number);
            currentDate = new Date(year, month - 1, day);
            if (activeLabelInfo) hidePopover();
            render();
            return;
        }

        if (clickedLabelEl || clickedCellEl) {
            e.stopPropagation();
        }

        const wasEditing = !!activeLabelInfo;
        if (wasEditing && activeLabelInfo.id !== Number(clickedLabelEl?.dataset.id)) {
            hidePopover();
        }

        if (clickedLabelEl) {
            const labelId = Number(clickedLabelEl.dataset.id);
            if (activeLabelInfo?.id === labelId) return;
            
            const labelData = labels.find(l => l.id === labelId);
            activeLabelInfo = { type: 'existing', id: labelId, style: { ...labelData.style } };
            render(); 
            
            setTimeout(() => {
                const activeLabelEl = document.querySelector(`.label[data-id="${labelId}"]`);
                if (activeLabelEl) {
                    activeLabelEl.focus();
                    showPopover(activeLabelEl);
                }
            }, 0);

        } else if (clickedCellEl) {
            if (activeLabelInfo?.type === 'new') return;
            
            const dateStr = clickedCellEl.dataset.date;
            const labelsOnDate = labels.filter(l => l.date === dateStr).length;
            activeLabelInfo = {
                type: 'new',
                date: dateStr,
                text: '新規ラベル',
                top: 5 + labelsOnDate * 28,
                left: 5,
                style: { ...defaultStyle }
            };
            render();

            setTimeout(() => {
                const newLabelEl = document.getElementById('temp-new-label');
                if (newLabelEl) {
                    newLabelEl.focus();
                    document.execCommand('selectAll', false, null);
                    showPopover(newLabelEl);
                }
            }, 0);
        }
    };

    const handlePopoverAction = (e) => {
        const action = e.target.dataset.action;
        if (!action) return;
        
        const activeLabelEl = document.querySelector('.label.editing');

        switch(action) {
            case 'save':
                if (activeLabelInfo?.type === 'new' && activeLabelEl) {
                    const newLabel = {
                        id: Date.now(),
                        date: activeLabelInfo.date,
                        text: activeLabelEl.innerText.trim() || '新規ラベル',
                        top: activeLabelInfo.top,
                        left: activeLabelInfo.left,
                        style: activeLabelInfo.style
                    };
                    labels.push(newLabel);
                }
                break;
            case 'update':
                if (activeLabelInfo?.type === 'existing' && activeLabelEl) {
                    const label = labels.find(l => l.id === activeLabelInfo.id);
                    if (label) {
                        label.text = activeLabelEl.innerText.trim();
                        label.style = activeLabelInfo.style;
                    }
                }
                break;
            case 'delete':
                if (activeLabelInfo?.type === 'existing') {
                    labels = labels.filter(l => l.id !== activeLabelInfo.id);
                }
                break;
            case 'duplicate':
                if (activeLabelInfo?.type === 'existing') {
                    const labelToCopy = labels.find(l => l.id === activeLabelInfo.id);
                    if (labelToCopy) {
                        clipboard = { text: labelToCopy.text, style: { ...labelToCopy.style } };
                    }
                }
                break;
            case 'paste':
                if (activeLabelInfo && clipboard) {
                    activeLabelInfo.text = clipboard.text;
                    activeLabelInfo.style = { ...clipboard.style };
                    render(); // Re-render to show pasted content immediately
                     setTimeout(() => {
                        const newLabelEl = document.querySelector('.label.editing');
                        if (newLabelEl) {
                            newLabelEl.focus();
                            showPopover(newLabelEl);
                        }
                    }, 0);
                }
                return; // Do not hide popover yet
            case 'save-template':
                if (activeLabelInfo?.type === 'existing') {
                    const labelToSave = labels.find(l => l.id === activeLabelInfo.id);
                     if (labelToSave) {
                        const newTemplate = {
                            id: Date.now(),
                            text: activeLabelEl.innerText.trim(),
                            style: { ...activeLabelInfo.style }
                        };
                        templates.push(newTemplate);
                        alert('テンプレートとして保存しました。');
                    }
                }
                break;
            case 'recall':
                 isTemplatePopoverVisible = true;
                 render();
                 return; // Do not hide popover yet
            case 'decorate':
                 showDecorationPopover();
                 return; // Do not hide popover
            case 'close':
            case 'cancel':
                break;
        }
        
        activeLabelInfo = null;
        popover.style.display = 'none';
        hideDecorationPopover();
        
        saveDataToLocalStorage();
        render();
    };
    
    const handleDocumentClick = (e) => {
        if (popover.contains(e.target) || 
            decorationPopover.contains(e.target) ||
            e.target.closest('.label.editing') || 
            e.target.closest('.template-popover-modal')) {
            return;
        }
        
        if (activeLabelInfo) {
            hidePopover();
        }

        if (isDatePickerVisible && !e.target.closest('.date-picker-container')) {
            isDatePickerVisible = false;
            render();
        }
    };
    
    const handleCalendarWheel = (e) => {
        e.preventDefault();
        if (isWheeling) return;
        isWheeling = true;

        if (e.deltaY < 0) {
            currentDate.setMonth(currentDate.getMonth() - 1);
        } else {
            currentDate.setMonth(currentDate.getMonth() + 1);
        }
        
        if(activeLabelInfo) hidePopover();
        render();

        setTimeout(() => {
            isWheeling = false;
        }, 100);
    };

    // --- Drag and Drop Handlers ---
    const handleDragStart = (e) => {
        const labelEl = e.target.closest('.label');
        if (!labelEl || labelEl.isContentEditable) return;

        hidePopover();

        const rect = labelEl.getBoundingClientRect();
        
        dragInfo = {
            id: Number(labelEl.dataset.id),
            element: labelEl,
            offsetX: e.clientX - rect.left,
            offsetY: e.clientY - rect.top,
            hasMoved: false,
            startX: e.clientX,
            startY: e.clientY,
        };

        document.addEventListener('mousemove', handleDragging);
        document.addEventListener('mouseup', handleDragEnd, { once: true });
    };

    const handleDragging = (e) => {
        if (!dragInfo) return;

        if (!dragInfo.hasMoved) {
            const dx = e.clientX - dragInfo.startX;
            const dy = e.clientY - dragInfo.startY;
            if (Math.sqrt(dx * dx + dy * dy) < 5) return;

            dragInfo.hasMoved = true;
            const labelEl = dragInfo.element;
            const computedStyle = window.getComputedStyle(labelEl);
            const width = computedStyle.width;
            
            labelEl.classList.add('dragging');
            labelEl.style.width = width;
            
            document.body.appendChild(labelEl);
        }

        dragInfo.element.style.top = `${e.clientY - dragInfo.offsetY}px`;
        dragInfo.element.style.left = `${e.clientX - dragInfo.offsetX}px`;
    };

    const handleDragEnd = (e) => {
        if (!dragInfo) return;

        const wasDragging = dragInfo.hasMoved;
        const draggedEl = dragInfo.element;

        document.removeEventListener('mousemove', handleDragging);

        if (!wasDragging) {
            dragInfo = null;
            return;
        }
        
        draggedEl.style.visibility = 'hidden';
        const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
        draggedEl.style.visibility = 'visible';
        
        const targetCell = elementBelow?.closest('.date-cell');

        if (targetCell) {
            const newDate = targetCell.dataset.date;
            const labelsContainer = targetCell.querySelector('.labels-container');
            const containerRect = labelsContainer.getBoundingClientRect();
            
            const newTop = e.clientY - containerRect.top - dragInfo.offsetY;
            const newLeft = e.clientX - containerRect.left - dragInfo.offsetX;

            const labelToUpdate = labels.find(l => l.id === dragInfo.id);
            if (labelToUpdate) {
                labelToUpdate.date = newDate;
                labelToUpdate.top = Math.max(0, newTop);
                labelToUpdate.left = Math.max(0, newLeft);
            }
        }
        
        draggedEl.remove();
        dragInfo = null;
        saveDataToLocalStorage();
        render(); 
    };
    
    // --- Data I/O Handlers ---
    const handleNew = () => {
        if (labels.length > 0 && !confirm('現在のラベルをすべてクリアして、新規作成しますか？\n保存していない変更は失われます。')) {
            return;
        }
        labels = [];
        templates = [];
        currentId = '';
        saveDataToLocalStorage();
        render();
    };

    const handleSaveFile = () => {
        const idInput = document.getElementById('calendar-id');
        currentId = idInput.value.trim();

        if (!currentId) {
            alert('IDを入力してください。');
            idInput.focus();
            return;
        }
        
        const filename = `${currentId}.json`;
        
        // Save both labels and templates
        const dataToSave = { labels, templates };
        const dataStr = JSON.stringify(dataToSave, null, 2);
        const dataBlob = new Blob([dataStr], {type: "application/json"});
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    };

    const handleImport = () => {
        const fileInput = document.getElementById('file-importer');
        fileInput.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = event => {
                try {
                    const importedJson = JSON.parse(event.target.result);
                    // Check if the file contains the new structure {labels, templates} or just an array (old format)
                    if (Array.isArray(importedJson)) {
                         labels = importedJson;
                         templates = []; // Reset templates for old format files
                    } else if (importedJson && Array.isArray(importedJson.labels)) {
                        labels = importedJson.labels;
                        templates = importedJson.templates || [];
                    } else {
                        throw new Error('JSONの形式が正しくありません。');
                    }

                    const fileName = file.name;
                    currentId = fileName.lastIndexOf('.') > 0 ? fileName.substring(0, fileName.lastIndexOf('.')) : fileName;
                    
                    saveDataToLocalStorage();
                    render();
                    alert('データを正常に読み込みました。');
                } catch (error) {
                    alert(`エラー: ファイルの読み込みに失敗しました。\n${error.message}`);
                } finally {
                    fileInput.value = '';
                }
            };
            reader.readAsText(file);
        };
        fileInput.click();
    };

    // --- レンダリング関数 ---
    const renderDatePickerPopover = () => {
        const monthNames = [...Array(12).keys()].map(i => `${i + 1}月`);
        const currentSelectedMonth = currentDate.getFullYear() === datePickerYear ? currentDate.getMonth() : -1;

        const monthButtonsHtml = monthNames.map((month, index) => `
            <button 
                class="month-btn ${index === currentSelectedMonth ? 'active' : ''}" 
                data-month="${index}">
                ${month}
            </button>
        `).join('');

        return `
        <div id="date-picker-popover">
            <div class="date-picker-header">
                <button id="prev-year-btn" aria-label="前の年">＜</button>
                <input type="number" id="year-input" value="${datePickerYear}" aria-label="年を入力">
                <button id="next-year-btn" aria-label="次の年">＞</button>
            </div>
            <div class="month-grid" role="group">
                ${monthButtonsHtml}
            </div>
            <div class="date-picker-footer">
                <button id="date-picker-today-btn">今日</button>
            </div>
        </div>
        `;
    }
    
    const handleTemplatePopoverAction = (e) => {
        e.stopPropagation(); // Stop event from bubbling to backdrop
        const target = e.target;
        const action = target.dataset.action;
        const templateItem = target.closest('.template-list-item');

        if (templateItem) {
            selectedTemplateId = Number(templateItem.dataset.id);
            renderTemplatePopover(); // Re-render to show selection
            return;
        }

        if (!action) return;

        switch (action) {
            case 'select':
                if (activeLabelInfo && selectedTemplateId) {
                    const template = templates.find(t => t.id === selectedTemplateId);
                    if (template) {
                        activeLabelInfo.text = template.text;
                        activeLabelInfo.style = { ...template.style };
                    }
                }
                isTemplatePopoverVisible = false;
                selectedTemplateId = null;
                render();
                // After re-rendering the main view, re-focus and show the main popover
                setTimeout(() => {
                    const activeLabelEl = document.querySelector('.label.editing');
                    if (activeLabelEl) {
                        activeLabelEl.focus();
                        showPopover(activeLabelEl);
                    }
                }, 0);
                break;
            case 'delete':
                 if (selectedTemplateId) {
                    templates = templates.filter(t => t.id !== selectedTemplateId);
                    selectedTemplateId = null;
                    saveDataToLocalStorage();
                    renderTemplatePopover();
                 }
                break;
            case 'close':
                isTemplatePopoverVisible = false;
                selectedTemplateId = null;
                render();
                break;
        }
    };

    const renderTemplatePopover = () => {
        if (!isTemplatePopoverVisible) {
            templatePopoverContainer.innerHTML = '';
            return;
        }

        let listContent = '';
        if (templates.length > 0) {
            listContent = templates.map(template => `
                <li class="template-list-item ${template.id === selectedTemplateId ? 'selected' : ''}" 
                    data-id="${template.id}" 
                    style="${getLabelStyle(template.style)}">
                    ${template.text}
                </li>
            `).join('');
        } else {
            listContent = '<div class="template-list-placeholder">保存されたテンプレートはありません。</div>';
        }

        const popoverHtml = `
            <div class="template-popover-backdrop">
                <div class="template-popover-modal">
                    <ul class="template-list">
                       ${listContent}
                    </ul>
                    <div class="template-popover-actions">
                         <button class="popover-btn" data-action="select" ${!selectedTemplateId ? 'disabled' : ''}>選択</button>
                         <button class="popover-btn" data-action="delete" ${!selectedTemplateId ? 'disabled' : ''}>削除</button>
                         <button class="popover-btn" data-action="close">閉じる</button>
                    </div>
                </div>
            </div>
        `;

        templatePopoverContainer.innerHTML = popoverHtml;
        templatePopoverContainer.querySelector('.template-popover-backdrop').addEventListener('click', (e) => {
            // Only close if backdrop itself is clicked
            if (e.target === e.currentTarget) {
                isTemplatePopoverVisible = false;
                selectedTemplateId = null;
                render();
            }
        });
        templatePopoverContainer.querySelector('.template-popover-modal').addEventListener('click', handleTemplatePopoverAction);
    };

    const render = () => {
      const year = currentDate.getFullYear();
      const month = currentDate.getMonth();

      const firstDayOfMonth = new Date(year, month, 1);
      const lastDayOfMonth = new Date(year, month + 1, 0);

      const startDate = new Date(firstDayOfMonth);
      startDate.setDate(startDate.getDate() - firstDayOfMonth.getDay());

      const endDate = new Date(lastDayOfMonth);
      endDate.setDate(endDate.getDate() + (6 - lastDayOfMonth.getDay()));

      const dates = [];
      let currentDatePointer = new Date(startDate);
      while (currentDatePointer <= endDate) {
        dates.push(new Date(currentDatePointer));
        currentDatePointer.setDate(currentDatePointer.getDate() + 1);
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const dayHeaders = ['日', '月', '火', '水', '木', '金', '土'];
      const dayHeadersHtml = dayHeaders.map((day, index) => `
        <div class="day-header ${index === 0 ? 'sunday' : ''} ${index === 6 ? 'saturday' : ''}" role="columnheader">
          ${day}
        </div>
      `).join('');

      const dateCellsHtml = dates.map(date => {
        const isOtherMonth = date.getMonth() !== month;
        const isToday = date.getTime() === today.getTime();
        const dayOfWeek = date.getDay();
        const isSunday = dayOfWeek === 0;
        const isSaturday = dayOfWeek === 6;

        const cellClasses = ['date-cell', isOtherMonth ? 'other-month' : ''].filter(Boolean).join(' ');
        const numberClasses = ['date-number', isToday ? 'today' : '', !isToday && isSunday ? 'sunday' : '', !isToday && isSaturday ? 'saturday' : ''].filter(Boolean).join(' ');

        const dateStr = formatDate(date);
        const labelsForDate = labels.filter(label => label.date === dateStr);
        let labelsHtml = labelsForDate.map(label => {
            const isEditing = activeLabelInfo?.type === 'existing' && activeLabelInfo.id === label.id;
            const classes = `label ${isEditing ? 'editing' : ''}`;
            const style = getLabelStyle(label.style);
            return `
            <div class="${classes}"
                 contenteditable="${isEditing}"
                 data-id="${label.id}"
                 style="top: ${label.top}px; left: ${label.left}px; ${style}"
            >${label.text}</div>
            `;
        }).join('');
        
        if (activeLabelInfo?.type === 'new' && activeLabelInfo.date === dateStr) {
            const style = getLabelStyle(activeLabelInfo.style);
            labelsHtml += `
            <div class="label editing"
                 id="temp-new-label"
                 contenteditable="true"
                 style="top: ${activeLabelInfo.top}px; left: ${activeLabelInfo.left}px; ${style}"
            >${activeLabelInfo.text}</div>
            `;
        }

        return `
          <div class="${cellClasses}" data-date="${dateStr}">
            <div class="${numberClasses}">${date.getDate()}</div>
            <div class="labels-container">${labelsHtml}</div>
          </div>
        `;
      }).join('');

      const appHtml = `
        <div class="app-container">
          <header class="header">
            <div class="header-top">
              <div class="date-picker-container">
                <button id="date-picker-trigger" class="header-title-btn" aria-haspopup="true" aria-expanded="${isDatePickerVisible}">
                  ${year}年 ${month + 1}月
                </button>
                ${isDatePickerVisible ? renderDatePickerPopover() : ''}
              </div>
              <div class="header-controls">
                <div class="id-control">
                  <label for="calendar-id">ID:</label>
                  <input type="text" id="calendar-id" placeholder="スケジュール名を入力">
                </div>
                <div class="data-ops">
                   <button id="new-btn">新規</button>
                   <button id="save-btn">保存</button>
                   <button id="import-btn">読込</button>
                </div>
              </div>
            </div>
          </header>
          <main class="calendar-board" id="calendar-board" aria-label="カレンダー">
            <div class="calendar-grid" id="calendar-grid">
              ${dayHeadersHtml}
              ${dateCellsHtml}
            </div>
          </main>
        </div>
      `;

      root.innerHTML = appHtml;

      // --- イベントリスナーの登録 ---
      document.getElementById('date-picker-trigger').addEventListener('click', toggleDatePicker);
      if (isDatePickerVisible) {
        document.getElementById('date-picker-popover').addEventListener('click', handleDatePickerClick);
        document.getElementById('year-input').addEventListener('input', handleYearInputChange);
      }
      
      document.getElementById('new-btn').addEventListener('click', handleNew);
      document.getElementById('save-btn').addEventListener('click', handleSaveFile);
      document.getElementById('import-btn').addEventListener('click', handleImport);

      const idInput = document.getElementById('calendar-id');
      idInput.value = currentId;
      idInput.addEventListener('input', e => {
        currentId = e.target.value;
      });

      const calendarGrid = document.getElementById('calendar-grid');
      calendarGrid.addEventListener('click', handleCalendarClick);
      calendarGrid.addEventListener('mousedown', handleDragStart);
      
      const calendarBoard = document.getElementById('calendar-board');
      calendarBoard.addEventListener('wheel', handleCalendarWheel);

      popover.addEventListener('click', handlePopoverAction);
      
      document.removeEventListener('click', handleDocumentClick);
      document.addEventListener('click', handleDocumentClick);

      // Render template popover if needed
      renderTemplatePopover();
    };

    // --- 初期化 ---
    const initialize = () => {
        loadDataFromLocalStorage();
        render();
    };
    
    initialize();
  </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>