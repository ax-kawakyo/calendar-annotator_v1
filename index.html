<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>カレンダーアノテーター</title>
  <style>
    /* 全体のスタイル */
    :root {
      --primary-color: #007bff;
      --border-color: #e0e0e0;
      --bg-light: #f4f7f9;
      --bg-white: #ffffff;
      --text-primary: #333;
      --text-secondary: #888;
      --text-sunday: #d9534f;
      --text-saturday: #428bca;
      --label-bg-default: #fffbe6;
      --popover-bg: #fff;
      --popover-shadow: rgba(0, 0, 0, 0.15);
      --danger-color: #dc3545;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      background-color: var(--bg-light);
      color: var(--text-primary);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    #root {
      display: flex;
      justify-content: center;
      padding: 20px;
    }
    .app-container {
      width: 100%;
      max-width: 1200px;
      min-width: 800px;
      background-color: var(--bg-white);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* ヘッダー */
    .header {
      padding: 16px 24px;
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
    }
    .header-top {
      display: flex;
      align-items: center;
      margin-bottom: 16px;
      gap: 16px;
    }
    .header-title {
      font-size: 1.5em;
      font-weight: 600;
      color: #2c3e50;
      margin: 0;
      white-space: nowrap;
    }
     .year-month-selector {
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 6px;
        transition: background-color 0.2s;
    }
    .year-month-selector:hover {
        background-color: #f0f0f0;
    }

    .id-control {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-left: auto; /* Push this and following elements to the right */
    }
    .id-control label {
        font-size: 1em;
        font-weight: 500;
        color: #555;
        white-space: nowrap;
    }
    .id-control input {
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 0.9em;
        min-width: 200px;
    }
    .data-ops {
        display: flex;
        gap: 8px;
    }
    .data-ops button {
      background-color: var(--bg-white);
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.2s ease-in-out;
      white-space: nowrap;
      font-weight: 500;
    }
    .data-ops button:hover {
      background-color: #f0f0f0;
      border-color: #bbb;
      transform: translateY(-1px);
    }
     .data-ops button:active {
      background-color: #e0e0e0;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
      transform: translateY(0);
    }
    
    /* --- Data Ops Button Colors --- */
    #new-btn {
        background-color: #fffbe6; color: #856404; border-color: #ffeeba;
    }
    #new-btn:hover { background-color: #fff8d6; }
    #save-btn {
        background-color: #e6f7f0; color: #1e875a; border-color: #a3d9c0;
    }
    #save-btn:hover { background-color: #d1f0e3; }
    #import-btn {
        background-color: #e7f3ff; color: #005bb5; border-color: #b3d7ff;
    }
    #import-btn:hover { background-color: #d0e7ff; }


    /* 装飾バー */
    .decoration-bar {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 12px 24px;
      border-bottom: 1px solid var(--border-color);
      background-color: #fcfcfc;
    }
    .deco-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .deco-control label {
      font-size: 13px;
      color: #555;
    }
    .deco-control input[type="color"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 28px;
      height: 28px;
      background-color: transparent;
      border: none;
      cursor: pointer;
      padding: 0;
    }
    .deco-control input[type="color"]::-webkit-color-swatch {
      border-radius: 50%;
      border: 1px solid var(--border-color);
    }
    .deco-control input[type="range"] {
      width: 100px;
    }
    .deco-control .font-size-value {
      font-size: 13px;
      width: 20px;
      text-align: right;
    }
    .style-btn-group button {
      background: var(--bg-white);
      border: 1px solid #ccc;
      font-size: 14px;
      padding: 4px 10px;
      cursor: pointer;
      pointer-events: all; /* クリックイベントを確実に拾う */
    }
    .style-btn-group button:first-child {
      border-radius: 4px 0 0 4px;
      border-right: none;
    }
    .style-btn-group button:last-child {
      border-radius: 0 4px 4px 0;
    }
    .style-btn-group button.active {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }

    /* カレンダーボード */
    .calendar-board {
      padding: 16px;
      flex-grow: 1;
    }
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 1px;
      background-color: var(--border-color);
      border: 1px solid var(--border-color);
      height: 100%;
      user-select: none; /* テキスト選択を防ぐ */
    }
    .day-header {
      text-align: center;
      padding: 10px 0;
      font-weight: 600;
      background-color: #f5f5f5;
    }
    .day-header.sunday { color: var(--text-sunday); }
    .day-header.saturday { color: var(--text-saturday); }

    /* 日付セル */
    .date-cell {
      position: relative;
      min-height: 120px;
      background-color: var(--bg-white);
      padding: 8px;
      transition: background-color 0.2s, box-shadow 0.2s;
      display: flex;
      flex-direction: column;
    }
    .date-cell.other-month {
      background-color: #fdfdfd;
      cursor: pointer;
    }
    .date-cell:not(.other-month) {
        cursor: pointer;
    }
    .date-cell.other-month .date-number {
      color: var(--text-secondary);
      opacity: 0.7;
    }
    .date-cell:not(.other-month):hover, .date-cell.other-month:hover {
        background-color: #eef7ff;
    }
    .date-cell.selected-for-template {
        box-shadow: inset 0 0 0 3px var(--primary-color);
        background-color: #eef7ff;
    }

    .date-number {
      font-size: 0.9em;
      font-weight: 500;
      text-align: left;
      margin-bottom: 4px;
    }
    .date-number.sunday { color: var(--text-sunday); }
    .date-number.saturday { color: var(--text-saturday); }
    .date-number.today {
        background-color: var(--primary-color);
        color: var(--bg-white);
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
    }
    .labels-container {
        flex-grow: 1;
        position: relative;
    }
    
    /* ラベル */
    .label {
      position: absolute;
      background-color: var(--label-bg-default);
      border: 1px solid transparent; /* 枠線を透明に変更 */
      border-radius: 4px;
      padding: 4px 6px;
      font-size: 0.85em;
      cursor: grab;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      z-index: 10;
      min-height: 20px;
      width: calc(100% - 10px); /* 親要素から少し内側に */
      word-wrap: break-word; /* テキストの折り返し */
      transition: transform 0.2s, box-shadow 0.2s, outline 0.2s;
    }
    .label.editing {
      outline: 2px solid var(--primary-color);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      z-index: 20;
      cursor: text;
    }
    .label[contenteditable="true"]:focus {
      outline: none; /* editingクラスで制御するため */
    }
    .label.dragging {
      opacity: 0.7;
      cursor: grabbing;
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
      z-index: 999;
      width: auto; 
    }
    .label.is-being-moved {
      outline: 2px dashed #ff8f00;
      box-shadow: 0 4px 12px rgba(255, 143, 0, 0.4);
      transform: scale(1.05);
      z-index: 50;
    }
    
    body.is-moving-label .date-cell:not(.other-month):hover {
      background-color: #fff8e1; /* Light yellow, indicating a valid drop target */
    }


    /* ポップオーバー */
    #popover {
      position: fixed;
      background-color: var(--popover-bg);
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--popover-shadow);
      padding: 12px;
      z-index: 100;
      border: 1px solid var(--border-color);
      transition: opacity 0.1s ease-in-out, transform 0.1s ease-in-out;
      min-width: 280px;
    }
    .popover-close-btn {
        position: absolute;
        top: 4px;
        right: 4px;
        width: 24px;
        height: 24px;
        border: none;
        background: transparent;
        font-size: 20px;
        line-height: 1;
        cursor: pointer;
        color: #888;
        opacity: 0.7;
    }
    .popover-close-btn:hover {
        opacity: 1;
        color: #000;
    }

    .popover-content {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    .popover-actions {
        display: flex;
        gap: 6px;
        flex-wrap: wrap; /* ボタンが折り返せるように */
    }
    .popover-template-section {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
     .popover-template-section select, .popover-template-section input {
        width: 100%;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 13px;
        box-sizing: border-box; /* paddingを含めてwidth 100%にする */
        flex-grow: 1;
    }
    .popover-section-label {
        font-size: 12px;
        font-weight: 500;
        text-align: left;
        width: 100%;
        color: #555;
    }
    #popover hr {
        border: none;
        border-top: 1px solid var(--border-color);
        margin: 0;
    }
    .popover-btn {
        background: none;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 8px 12px;
        font-size: 13px;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s, color 0.2s;
        white-space: nowrap;
        font-weight: 500;
    }
    .popover-btn:hover {
        background-color: #f0f0f0;
    }

    /* --- Popover Button Color Scheme --- */

    /* Constructive actions (Apply, Update, Paste) - Light Blue */
    .popover-btn[data-action="apply-template"],
    .popover-btn[data-action="update"],
    .popover-btn[data-action="paste"],
    .popover-btn[data-action="import"] {
        background-color: #e7f3ff;
        color: #005bb5;
        border: 1px solid #b3d7ff;
    }
    .popover-btn[data-action="apply-template"]:hover,
    .popover-btn[data-action="update"]:hover,
    .popover-btn[data-action="paste"]:hover,
    .popover-btn[data-action="import"]:hover {
        background-color: #d0e7ff;
        border-color: #8ac2ff;
    }

    /* Creation actions (Save Template, Save Label, Copy) - Light Green */
    .popover-btn[data-action="save-as-template"],
    .popover-btn[data-action="save"],
    .popover-btn[data-action="copy"],
    .popover-btn[data-action="save-json"] {
        background-color: #e6f7f0;
        color: #1e875a;
        border: 1px solid #a3d9c0;
    }
    .popover-btn[data-action="save-as-template"]:hover,
    .popover-btn[data-action="save"]:hover,
    .popover-btn[data-action="copy"]:hover,
    .popover-btn[data-action="save-json"]:hover {
        background-color: #d1f0e3;
        border-color: #82c9ab;
    }

    /* Destructive/Neutral actions (Delete, Cancel) - Light Red */
    .popover-btn[data-action="delete-template"],
    .popover-btn[data-action="delete"],
    .popover-btn[data-action="cancel"] {
        background-color: #fbebeb;
        color: var(--danger-color);
        border: 1px solid #f5c6cb;
    }
    .popover-btn[data-action="delete-template"]:hover,
    .popover-btn[data-action="delete"]:hover,
    .popover-btn[data-action="cancel"]:hover {
        background-color: #f8d7da;
        border-color: #f1b0b7;
    }
    
    /* New action - Light Yellow */
    .popover-btn[data-action="new"] {
        background-color: #fffbe6;
        color: #856404;
        border-color: #ffeeba;
    }
    .popover-btn[data-action="new"]:hover {
        background-color: #fff8d6;
    }

    /* Move action - Light Orange */
    .popover-btn[data-action="move"] {
        background-color: #fff8e1;
        color: #ff8f00;
        border: 1px solid #ffecb3;
    }
    .popover-btn[data-action="move"]:hover {
        background-color: #ffefc2;
        border-color: #ffe082;
    }

    /* --- Year Month Popover --- */
    .year-month-popover-content {
        display: flex;
        flex-direction: column;
        gap: 16px;
    }
    .year-selector-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
    }
    .year-selector-header button {
        background: none; border: none; font-size: 20px; cursor: pointer; padding: 0 10px;
    }
    .year-selector-header input {
        font-size: 1.1em; font-weight: bold; text-align: center; border: 1px solid #ccc; border-radius: 4px; width: 80px; padding: 4px;
    }
    .month-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
    }
    .month-grid-item {
        background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 4px; padding: 10px 0; text-align: center; cursor: pointer;
        transition: background-color 0.2s;
    }
    .month-grid-item:hover { background-color: #eef7ff; }
    .month-grid-item.current { background-color: var(--primary-color); color: white; font-weight: bold; }
    .popover-footer {
        display: flex;
        justify-content: center;
        border-top: 1px solid var(--border-color);
        padding-top: 12px;
    }
    .popover-footer button {
        width: 100%;
        background-color: #e7f3ff; color: #005bb5; border: 1px solid #b3d7ff;
        padding: 8px; border-radius: 4px; font-weight: 500; cursor: pointer;
    }
     .popover-footer button:hover { background-color: #d0e7ff; }

    /* --- レスポンシブデザイン --- */
    @media (max-width: 768px) {
      body {
        -webkit-text-size-adjust: 100%; /* iOSでの自動フォントサイズ調整を無効化 */
      }
      #root {
        padding: 0;
      }
      .app-container {
        min-width: 100%;
        border-radius: 0;
        box-shadow: none;
        height: 100vh; /* 画面の高さいっぱいに広げる */
      }
      .header {
        padding: 8px 12px;
        flex-shrink: 0;
      }
      .header-top {
        flex-direction: column;
        gap: 8px;
        margin-bottom: 0;
      }
      .header-title-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        gap: 8px;
      }
      .header-title {
        font-size: 1.2em;
        margin: 0;
        flex-shrink: 0;
      }
      .id-control {
        margin-left: 0;
        flex-grow: 1;
        width: 100%;
        cursor: pointer;
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 6px 10px;
        background-color: #f9f9f9;
        display: flex;
        align-items: center;
        justify-content: space-between;
        min-width: 0;
      }
      .id-control:hover {
        background-color: #f0f0f0;
      }
      .id-control input {
        border: none;
        padding: 0;
        font-size: 1em;
        background: transparent;
        width: 100%;
        pointer-events: none; /* Make clicks pass through to the parent container */
      }
      .id-control input:read-only {
        pointer-events: none;
      }
      .id-control input:not(:read-only) {
        pointer-events: auto;
        cursor: text;
      }
      .id-control::after {
        content: '☰';
        color: #888;
        font-size: 1.1em;
        margin-left: 8px;
      }
      .data-ops {
        display: none; /* Hide original buttons on mobile */
      }
      .decoration-bar {
        display: none;
      }
      .calendar-board {
        padding: 4px;
        flex-grow: 1;
        overflow-y: auto; /* カレンダー部分がスクロールできるように */
      }
      .day-header {
        padding: 4px 0;
        font-size: 0.75em;
        font-weight: 500;
        height: auto;
      }
      .date-cell {
        min-height: 100px; /* セルの高さを確保 */
        padding: 4px;
        display: flex;
        flex-direction: column;
      }
      .labels-container {
        flex-grow: 1;
      }
      .date-number {
        font-size: 0.8em;
      }
      .date-number.today {
        width: 20px;
        height: 20px;
      }
      .label {
        font-size: 0.75em;
        padding: 2px 4px;
        min-height: 16px;
      }
      #popover {
        /* 画面下部からスライドアップするような見た目も良いが、まずは中央に表示 */
        left: 50% !important;
        top: 50% !important;
        transform: translate(-50%, -50%);
        max-width: 90vw;
        box-sizing: border-box;
      }
    }

    @media (max-width: 380px) {
        .header-title {
            font-size: 1em;
        }
        .id-control input::placeholder {
            font-size: 0.9em;
        }
    }


  </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
  <div id="root"></div>
  <div id="popover" style="display: none;"></div>
  <input type="file" id="file-importer" accept=".json" style="display: none;">

  <script type="module">
    // --- アプリケーションの状態 ---
    let currentDate = new Date();
    // ラベルデータ構造: { id, date, text, top, left, style: { color, backgroundColor, fontSize, fontWeight, fontStyle } }
    let labels = []; 
    // テンプレートデータ構造: { name, labels: [{ text, top, left, style }] }
    let templates = [];
    let currentId = '';
    let selectedDateForTemplate = null; // 'YYYY-MM-DD'
    let activeLabelInfo = null; // { type, id?, date?, text?, top?, left?, style? }
    let clipboard = null; // { text, style }
    let dragInfo = null; // { id, element, offsetX, offsetY, hasMoved, startX, startY }
    let moveInfo = null; // { labelId } - for tap-based moving on mobile
    let clickTimer = null; // for distinguishing single/double clicks
    let defaultStyle = {
        color: '#333333',
        backgroundColor: '#fffbe6',
        fontSize: '13',
        fontWeight: 'normal',
        fontStyle: 'normal',
    };
    const LOCAL_STORAGE_KEY_LABELS = 'calendar-annotator-labels';
    const LOCAL_STORAGE_KEY_TEMPLATES = 'calendar-annotator-templates';

    // --- DOM要素 ---
    const root = document.getElementById('root');
    const popover = document.getElementById('popover');

    // --- Data Persistence ---
    const saveLabelsToLocalStorage = () => {
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY_LABELS, JSON.stringify({ labels, currentId }));
        } catch (e) { console.error("Failed to save labels:", e); }
    };
    
    const loadLabelsFromLocalStorage = () => {
        try {
            const savedData = localStorage.getItem(LOCAL_STORAGE_KEY_LABELS);
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                labels = parsedData.labels || [];
                currentId = parsedData.currentId || '';
            }
        } catch (e) {
            console.error("Failed to load labels:", e);
            labels = [];
            currentId = '';
        }
    };

    const saveTemplatesToLocalStorage = () => {
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY_TEMPLATES, JSON.stringify(templates));
        } catch (e) { console.error("Failed to save templates:", e); }
    };

    const loadTemplatesFromLocalStorage = () => {
        try {
            const savedData = localStorage.getItem(LOCAL_STORAGE_KEY_TEMPLATES);
            if (savedData) {
                templates = JSON.parse(savedData) || [];
            }
        } catch (e) {
            console.error("Failed to load templates:", e);
            templates = [];
        }
    };

    // --- Helper Functions ---
    const formatDate = (date) => {
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, '0');
        const d = String(date.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
    }
    
    const getLabelStyle = (styleObj) => {
        if (!styleObj) return '';
        return `
            color: ${styleObj.color}; 
            background-color: ${styleObj.backgroundColor}; 
            font-size: ${styleObj.fontSize}px; 
            font-weight: ${styleObj.fontWeight}; 
            font-style: ${styleObj.fontStyle};
        `;
    }

    // --- Popover Functions ---
    const showPopover = (targetElement, type) => {
        const rect = targetElement.getBoundingClientRect();
        let popoverHtml = `<button class="popover-close-btn" data-action="close">&times;</button>`;

        if (type === 'cell') {
            const templateOptionsHtml = templates.map(t => `<option value="${t.name}">${t.name}</option>`).join('');
            popoverHtml += `
                <div class="popover-content">
                    <div class="popover-template-section">
                        <label class="popover-section-label" for="popover-template-select">テンプレートを適用</label>
                        <div class="popover-actions">
                           <select id="popover-template-select" style="flex-grow: 2;">
                                <option value="">選択...</option>
                                ${templateOptionsHtml}
                           </select>
                           <button class="popover-btn" data-action="apply-template">適用</button>
                           <button class="popover-btn" data-action="delete-template">削除</button>
                        </div>
                    </div>
                    <hr>
                    <div class="popover-template-section">
                        <label class="popover-section-label" for="new-template-name-input">この日をテンプレートとして保存</label>
                        <div class="popover-actions">
                             <input type="text" id="new-template-name-input" placeholder="新しいテンプレート名" style="flex-grow: 2;">
                             <button class="popover-btn" data-action="save-as-template">保存</button>
                        </div>
                    </div>
                </div>`;
            popover.style.left = `${rect.left}px`;
            popover.style.top = `${rect.bottom + 4}px`;
        } else if (type === 'yearMonth') {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            let monthsHtml = '';
            for (let i = 0; i < 12; i++) {
                const isCurrent = i === month;
                monthsHtml += `<button class="month-grid-item ${isCurrent ? 'current' : ''}" data-month="${i}">${i + 1}月</button>`;
            }
            popoverHtml += `
                <div class="year-month-popover-content">
                    <div class="year-selector-header">
                        <button data-action="prev-year">‹</button>
                        <input type="number" id="year-input" value="${year}">
                        <button data-action="next-year">›</button>
                    </div>
                    <div class="month-grid">${monthsHtml}</div>
                    <div class="popover-footer">
                        <button data-action="go-today">今日</button>
                    </div>
                </div>`;
             popover.style.left = `${rect.left}px`;
             popover.style.top = `${rect.bottom + 8}px`;

        } else if (type === 'dataOps') {
            popoverHtml += `
                <div class="popover-content">
                    <div class="popover-actions" style="flex-direction: column;">
                        <button class="popover-btn" data-action="new">新規作成</button>
                        <button class="popover-btn" data-action="save-json">名前を付けて保存</button>
                        <button class="popover-btn" data-action="import">ファイルから読込</button>
                    </div>
                </div>
            `;
            popover.style.left = `${rect.left}px`;
            popover.style.top = `${rect.bottom + 4}px`;
        } else { // 'newLabel' or 'existingLabel'
            let buttonsHtml = '';
            if (type === 'newLabel') {
                let pasteButtonHtml = clipboard ? `<button class="popover-btn" data-action="paste">貼付</button>` : '';
                buttonsHtml = `${pasteButtonHtml}<button class="popover-btn" data-action="save">保存</button><button class="popover-btn" data-action="cancel">取消</button>`;
            } else { // 'existingLabel'
                buttonsHtml = `<button class="popover-btn" data-action="update">更新</button><button class="popover-btn" data-action="move">移動</button><button class="popover-btn" data-action="copy">コピー</button><button class="popover-btn" data-action="delete">削除</button>`;
            }
            popoverHtml += `<div class="popover-actions">${buttonsHtml}</div>`;
            // ポップオーバーをラベルの右側に表示
            popover.style.left = `${rect.right + 8}px`;
            popover.style.top = `${rect.top}px`;
            popover.style.minWidth = 'auto'; // ラベル用はコンパクトに
        }
        
        popover.innerHTML = popoverHtml;
        popover.style.display = 'block';

        // スマホの場合はtransformをリセット
        if (window.innerWidth <= 768) {
            popover.style.transform = '';
        }

        if (type === 'yearMonth') {
             const yearInput = document.getElementById('year-input');
             yearInput.addEventListener('change', (e) => {
                const newYear = parseInt(e.target.value, 10);
                if (!isNaN(newYear)) {
                    currentDate.setFullYear(newYear);
                    // ポップオーバーを再描画して月グリッドを更新
                    showPopover(targetElement, 'yearMonth');
                }
             });
        }
    };
    
    const hidePopover = () => {
        if(activeLabelInfo || selectedDateForTemplate || moveInfo) {
            activeLabelInfo = null;
            selectedDateForTemplate = null;
            moveInfo = null; // 移動モードもキャンセル
            render();
        }
        popover.style.display = 'none';
        popover.style.minWidth = '280px'; // デフォルトに戻す
    };
    
    // --- Decoration Bar Functions ---
    const updateDecorationBar = () => {
        if (window.innerWidth <= 768) return; // スマホでは非表示なので何もしない
        const currentStyle = activeLabelInfo?.style || defaultStyle;

        document.getElementById('text-color-picker').value = currentStyle.color;
        document.getElementById('label-color-picker').value = currentStyle.backgroundColor;
        const fontSizeSlider = document.getElementById('font-size-slider');
        fontSizeSlider.value = currentStyle.fontSize;
        document.getElementById('font-size-value').textContent = currentStyle.fontSize;
        
        document.getElementById('bold-btn').classList.toggle('active', currentStyle.fontWeight === 'bold');
        document.getElementById('italic-btn').classList.toggle('active', currentStyle.fontStyle === 'italic');
    };

    const handleDecorationChange = (e) => {
        const target = e.target.closest('[data-style]');
        if (!target) return;

        const styleProp = target.dataset.style;
        let value = target.value;

        const isToggleButton = target.tagName === 'BUTTON';
        const targetStyle = activeLabelInfo?.style || defaultStyle;

        if (isToggleButton) {
            const currentVal = targetStyle[styleProp];
            if (styleProp === 'fontWeight') value = currentVal === 'bold' ? 'normal' : 'bold';
            if (styleProp === 'fontStyle') value = currentVal === 'italic' ? 'normal' : 'italic';
        }

        targetStyle[styleProp] = value;

        if (activeLabelInfo) {
            const activeLabelEl = document.querySelector('.label.editing');
            if (activeLabelEl) {
                 if(styleProp === 'fontSize') {
                    activeLabelEl.style.fontSize = `${value}px`;
                    document.getElementById('font-size-value').textContent = value;
                } else if (styleProp === 'fontWeight' || styleProp === 'fontStyle' || styleProp === 'color' || styleProp === 'backgroundColor') {
                    activeLabelEl.style[target.dataset.cssProp] = value;
                }
            }
        } else {
             if (styleProp === 'fontSize') {
                document.getElementById('font-size-value').textContent = value;
            }
        }
        updateDecorationBar();
    };

    // --- イベントハンドラ ---
    const handleCalendarClick = (e) => {
        // 移動モードの場合の処理を最優先
        if (moveInfo) {
            const targetCell = e.target.closest('.date-cell');
            if (targetCell) {
                const labelToMove = labels.find(l => l.id === moveInfo.labelId);
                if (labelToMove) {
                    const newDate = targetCell.dataset.date;
                    const labelsOnNewDate = labels.filter(l => l.date === newDate && l.id !== labelToMove.id).length;
                    labelToMove.date = newDate;
                    labelToMove.top = 5 + labelsOnNewDate * 28; // 衝突を避ける
                    labelToMove.left = 5;
                }
            }
            moveInfo = null;
            saveLabelsToLocalStorage();
            render();
            return;
        }
        
        if (dragInfo && dragInfo.hasMoved) return;

        const clickedLabelEl = e.target.closest('.label');
        const clickedCellEl = e.target.closest('.date-cell');

        if (e.target.closest('#popover') || e.target.closest('.decoration-bar')) {
            return;
        }

        const isPopoverVisible = popover.style.display !== 'none';
        if(isPopoverVisible && !clickedLabelEl && !clickedCellEl) {
            hidePopover();
            return;
        }

        const performSingleClickAction = (cellEl) => {
            if (cellEl.classList.contains('other-month')) {
                const dateStr = cellEl.dataset.date;
                const [year, month, day] = dateStr.split('-').map(Number);
                currentDate = new Date(year, month - 1, day);
                hidePopover();
                render();
            } else {
                e.stopPropagation();
                const dateStr = cellEl.dataset.date;
                if (selectedDateForTemplate === dateStr) return;
                
                if (activeLabelInfo) hidePopover();
                
                selectedDateForTemplate = dateStr;
                render();
                showPopover(cellEl, 'cell');
            }
            updateDecorationBar();
        };

        if (clickedLabelEl) {
            if (clickTimer) clearTimeout(clickTimer); // ダブルクリック待機をキャンセル
            e.stopPropagation();
            if (selectedDateForTemplate) {
                selectedDateForTemplate = null;
                render();
            }
            const labelId = Number(clickedLabelEl.dataset.id);
            if (activeLabelInfo?.id === labelId) return;
            
            if (activeLabelInfo) hidePopover();

            const labelData = labels.find(l => l.id === labelId);
            activeLabelInfo = { type: 'existing', id: labelId, style: { ...labelData.style } };
            render(); 
            
            setTimeout(() => {
                const activeLabelEl = document.querySelector(`.label[data-id="${labelId}"]`);
                if (activeLabelEl) {
                    activeLabelEl.focus();
                    showPopover(activeLabelEl, 'existingLabel');
                }
            }, 0);
             updateDecorationBar();
        } else if (clickedCellEl) {
            clearTimeout(clickTimer);
            clickTimer = setTimeout(() => {
                performSingleClickAction(clickedCellEl);
            }, 250); // 少し長くして誤認識を防ぐ
        }
    };
    
    const handleCalendarDblClick = (e) => {
        if (clickTimer) clearTimeout(clickTimer); // シングルクリックのタイマーをキャンセル

        const clickedCellEl = e.target.closest('.date-cell:not(.other-month)');
        if (!clickedCellEl || moveInfo) return;
        
        hidePopover();

        const dateStr = clickedCellEl.dataset.date;
        const labelsOnDate = labels.filter(l => l.date === dateStr).length;
        activeLabelInfo = {
            type: 'new',
            date: dateStr,
            text: '新規ラベル',
            top: 5 + labelsOnDate * 28,
            left: 5,
            style: { ...defaultStyle }
        };
        render();

        setTimeout(() => {
            const newLabelEl = document.getElementById('temp-new-label');
            if (newLabelEl) {
                newLabelEl.focus();
                document.execCommand('selectAll', false, null);
                showPopover(newLabelEl, 'newLabel');
            }
        }, 0);
        updateDecorationBar();
    };

    const handlePopoverAction = (e) => {
        const action = e.target.dataset.action;
        const month = e.target.dataset.month;
        if (!action && month === undefined) return;

        if(month !== undefined) {
             currentDate.setMonth(parseInt(month, 10));
             hidePopover();
             render();
             return;
        }

        if (action === 'close') {
            hidePopover();
            return;
        }

        // --- Data Ops popover actions
        if (action === 'new') {
            handleNew();
            hidePopover();
            return;
        }
        if (action === 'save-json') {
            handleSave();
            hidePopover();
            return;
        }
        if (action === 'import') {
            handleImport();
            hidePopover();
            return;
        }


        switch(action) {
            case 'prev-year':
                currentDate.setFullYear(currentDate.getFullYear() - 1);
                showPopover(document.getElementById('year-month-selector'), 'yearMonth');
                return;
            case 'next-year':
                 currentDate.setFullYear(currentDate.getFullYear() + 1);
                 showPopover(document.getElementById('year-month-selector'), 'yearMonth');
                 return;
            case 'go-today':
                 currentDate = new Date();
                 hidePopover();
                 render();
                 return;
        }

        const activeLabelEl = document.querySelector('.label.editing');

        switch(action) {
            case 'save':
                if (activeLabelInfo?.type === 'new' && activeLabelEl) {
                    const newLabel = {
                        id: Date.now(),
                        date: activeLabelInfo.date,
                        text: activeLabelEl.innerText.trim() || '新規ラベル',
                        top: activeLabelInfo.top,
                        left: activeLabelInfo.left,
                        style: activeLabelInfo.style
                    };
                    labels.push(newLabel);
                    hidePopover();
                }
                break;
            case 'update':
                if (activeLabelInfo?.type === 'existing' && activeLabelEl) {
                    const label = labels.find(l => l.id === activeLabelInfo.id);
                    if (label) {
                        label.text = activeLabelEl.innerText.trim();
                        label.style = activeLabelInfo.style;
                    }
                    hidePopover();
                }
                break;
            case 'delete':
                if (activeLabelInfo?.type === 'existing') {
                    labels = labels.filter(l => l.id !== activeLabelInfo.id);
                    hidePopover();
                }
                break;
            case 'copy':
                if (activeLabelInfo?.type === 'existing') {
                    const labelToCopy = labels.find(l => l.id === activeLabelInfo.id);
                    if (labelToCopy) {
                        clipboard = { text: labelToCopy.text, style: { ...labelToCopy.style } };
                    }
                    hidePopover();
                }
                break;
            case 'paste':
                if (activeLabelInfo?.type === 'new' && clipboard) {
                    const newLabel = {
                        id: Date.now(),
                        date: activeLabelInfo.date,
                        text: clipboard.text,
                        top: activeLabelInfo.top,
                        left: activeLabelInfo.left,
                        style: { ...clipboard.style }
                    };
                    labels.push(newLabel);
                    hidePopover();
                }
                break;
            case 'move':
                e.stopPropagation(); // BUGFIX: これがないと即座にhandleDocumentClickが発火して移動モードがキャンセルされる
                if (activeLabelInfo?.type === 'existing') {
                    moveInfo = { labelId: activeLabelInfo.id };
                    activeLabelInfo = null;
                    popover.style.display = 'none';
                    render();
                }
                return;
            case 'cancel':
                hidePopover();
                break;
            
            case 'save-as-template': {
                if (!selectedDateForTemplate) return;
                
                const templateNameInput = document.getElementById('new-template-name-input');
                if (!templateNameInput) return;
                const templateName = templateNameInput.value.trim();

                if (!templateName) {
                    alert('テンプレート名を入力してください。');
                    templateNameInput.focus();
                    return;
                }

                const labelsOnDate = labels.filter(l => l.date === selectedDateForTemplate);
                if (labelsOnDate.length === 0) {
                    alert('テンプレートとして保存するラベルがありません。');
                    return;
                }
                
                if (templates.some(t => t.name === templateName)) {
                    if (!confirm(`テンプレート名 "${templateName}" は既に存在します。上書きしますか？`)) {
                        return;
                    }
                    templates = templates.filter(t => t.name !== templateName);
                }

                const templateLabels = labelsOnDate.map(({ text, top, left, style }) => ({ text, top, left, style: {...style} }));
                templates.push({ name: templateName, labels: templateLabels });
                templates.sort((a, b) => a.name.localeCompare(b.name));
                saveTemplatesToLocalStorage();
                alert(`テンプレート "${templateName}" を保存しました。`);
                hidePopover();
                break;
            }
            case 'apply-template':
                if (!selectedDateForTemplate) return;
                const templateSelect = document.getElementById('popover-template-select');
                const selectedTemplateName = templateSelect.value;
                if (!selectedTemplateName) {
                    alert('適用するテンプレートを選択してください。');
                    return;
                }
                const template = templates.find(t => t.name === selectedTemplateName);
                if (template) {
                    template.labels.forEach(templateLabel => {
                        labels.push({
                            id: Date.now() + Math.random(),
                            date: selectedDateForTemplate,
                            text: templateLabel.text,
                            top: templateLabel.top,
                            left: templateLabel.left,
                            style: { ...templateLabel.style }
                        });
                    });
                    render();
                }
                break;
             case 'delete-template':
                if (!selectedDateForTemplate) return;
                const templateToDelete = document.getElementById('popover-template-select').value;
                if (!templateToDelete) {
                     alert('削除するテンプレートを選択してください。');
                    return;
                }
                if (confirm(`テンプレート "${templateToDelete}" を削除しますか？`)) {
                    templates = templates.filter(t => t.name !== templateToDelete);
                    saveTemplatesToLocalStorage();
                    const cellEl = document.querySelector(`.date-cell[data-date="${selectedDateForTemplate}"]`);
                    if (cellEl) showPopover(cellEl, 'cell');
                }
                break;
        }

        if (action !== 'copy' && action !== 'apply-template' && action !== 'delete-template') {
            saveLabelsToLocalStorage();
            render();
            updateDecorationBar();
        }
    };
    
    const handleDocumentClick = (e) => {
        // popoverの内部、またはpopoverをトリガーした要素をクリックした場合は何もしない
        if (e.target.closest('#popover') || 
            e.target.closest('.year-month-selector') ||
            e.target.closest('.id-control')) {
            return;
        }

        if (e.target.closest('.label.editing') || 
            e.target.closest('.decoration-bar')) {
            return;
        }
        
        // 上記以外でpopoverが表示されている場合は閉じる
        if (popover.style.display !== 'none') {
            hidePopover();
        }
        
        // 編集中のラベルや選択中のセルがある場合、それを解除する
        if (activeLabelInfo || selectedDateForTemplate || moveInfo) {
            hidePopover();
            updateDecorationBar();
        }
    };

    // --- Drag and Drop Handlers ---
    const handleDragStart = (e) => {
        if (window.matchMedia("(pointer: coarse)").matches) {
            return;
        }
        const labelEl = e.target.closest('.label');
        if (!labelEl || labelEl.isContentEditable || moveInfo) return;

        hidePopover();

        const rect = labelEl.getBoundingClientRect();
        
        dragInfo = {
            id: Number(labelEl.dataset.id),
            element: labelEl,
            offsetX: e.clientX - rect.left,
            offsetY: e.clientY - rect.top,
            hasMoved: false,
            startX: e.clientX,
            startY: e.clientY,
        };

        document.addEventListener('mousemove', handleDragging);
        document.addEventListener('mouseup', handleDragEnd, { once: true });
    };

    const handleDragging = (e) => {
        if (!dragInfo) return;

        if (!dragInfo.hasMoved) {
            const dx = e.clientX - dragInfo.startX;
            const dy = e.clientY - dragInfo.startY;
            if (Math.sqrt(dx * dx + dy * dy) < 5) return;

            dragInfo.hasMoved = true;
            const labelEl = dragInfo.element;
            const computedStyle = window.getComputedStyle(labelEl);
            const width = computedStyle.width;
            
            labelEl.classList.add('dragging');
            labelEl.style.width = width;
            
            document.body.appendChild(labelEl);
        }

        dragInfo.element.style.top = `${e.clientY - dragInfo.offsetY}px`;
        dragInfo.element.style.left = `${e.clientX - dragInfo.offsetX}px`;
    };

    const handleDragEnd = (e) => {
        if (!dragInfo) return;

        const wasDragging = dragInfo.hasMoved;
        const draggedEl = dragInfo.element;

        document.removeEventListener('mousemove', handleDragging);

        if (!wasDragging) {
            dragInfo = null;
            return;
        }
        
        draggedEl.style.visibility = 'hidden';
        const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
        draggedEl.style.visibility = 'visible';
        
        const targetCell = elementBelow?.closest('.date-cell:not(.other-month)');

        if (targetCell) {
            const newDate = targetCell.dataset.date;
            const labelsContainer = targetCell.querySelector('.labels-container');
            const containerRect = labelsContainer.getBoundingClientRect();
            
            const newTop = e.clientY - containerRect.top - dragInfo.offsetY;
            const newLeft = e.clientX - containerRect.left - dragInfo.offsetX;

            const labelToUpdate = labels.find(l => l.id === dragInfo.id);
            if (labelToUpdate) {
                labelToUpdate.date = newDate;
                labelToUpdate.top = Math.max(0, newTop);
                labelToUpdate.left = Math.max(0, newLeft);
            }
        }
        
        draggedEl.remove();
        dragInfo = null;
        saveLabelsToLocalStorage();
        render(); 
    };
    
    // --- Data I/O Handlers ---
    const handleNew = () => {
        if (labels.length > 0 && !confirm('現在のラベルをすべてクリアして、新規作成しますか？\n保存していない変更は失われます。')) {
            return;
        }
        labels = [];
        currentId = '';
        selectedDateForTemplate = null;
        saveLabelsToLocalStorage();
        render();
        
        // After render, make input editable on mobile
        if (window.innerWidth <= 768) {
            const idInput = document.getElementById('calendar-id');
            idInput.readOnly = false;
            idInput.focus();
            idInput.select(); // Select current text for easy replacement
            
            // Add a one-time listener to make it readonly again on blur
            idInput.addEventListener('blur', () => {
                idInput.readOnly = true;
            }, { once: true });
        }
    };

    const handleSave = () => {
        const idInput = document.getElementById('calendar-id');
        currentId = idInput.value.trim();

        if (!currentId) {
            alert('IDを入力してください。');
            idInput.focus();
            return;
        }
        
        const now = new Date();
        const timestamp = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
        const filename = `${currentId}_${timestamp}.json`;

        const dataStr = JSON.stringify(labels, null, 2);
        const dataBlob = new Blob([dataStr], {type: "application/json"});
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    };

    const handleImport = () => {
        const fileInput = document.getElementById('file-importer');
        fileInput.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = event => {
                try {
                    const importedData = JSON.parse(event.target.result);
                    if (Array.isArray(importedData)) {
                        labels = importedData;
                        const fileName = file.name;
                        currentId = fileName.lastIndexOf('.') > 0 ? fileName.substring(0, fileName.lastIndexOf('.')) : fileName;
                        
                        saveLabelsToLocalStorage();
                        render();
                        alert('データを正常に読み込みました。');
                    } else {
                        alert('エラー: JSONファイルが正しい配列形式ではありません。');
                    }
                } catch (error) {
                    alert(`エラー: ファイルの読み込みに失敗しました。\n${error.message}`);
                } finally {
                    fileInput.value = '';
                }
            };
            reader.readAsText(file);
        };
        fileInput.click();
    };

    // --- レンダリング関数 ---
    const render = () => {
      document.body.classList.toggle('is-moving-label', !!moveInfo);

      const year = currentDate.getFullYear();
      const month = currentDate.getMonth();

      const firstDayOfMonth = new Date(year, month, 1);
      const lastDayOfMonth = new Date(year, month + 1, 0);

      const startDate = new Date(firstDayOfMonth);
      startDate.setDate(startDate.getDate() - firstDayOfMonth.getDay());

      const endDate = new Date(lastDayOfMonth);
      endDate.setDate(endDate.getDate() + (6 - lastDayOfMonth.getDay()));

      const dates = [];
      let currentDatePointer = new Date(startDate);
      while (currentDatePointer <= endDate) {
        dates.push(new Date(currentDatePointer));
        currentDatePointer.setDate(currentDatePointer.getDate() + 1);
      }

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const dayHeaders = ['日', '月', '火', '水', '木', '金', '土'];
      const dayHeadersHtml = dayHeaders.map((day, index) => `
        <div class="day-header ${index === 0 ? 'sunday' : ''} ${index === 6 ? 'saturday' : ''}" role="columnheader">
          ${day}
        </div>
      `).join('');

      const dateCellsHtml = dates.map(date => {
        const isOtherMonth = date.getMonth() !== month;
        const isToday = date.getTime() === today.getTime();
        const dayOfWeek = date.getDay();
        const isSunday = dayOfWeek === 0;
        const isSaturday = dayOfWeek === 6;
        const dateStr = formatDate(date);
        
        const isSelectedForTemplate = selectedDateForTemplate === dateStr;

        const cellClasses = ['date-cell', isOtherMonth ? 'other-month' : '', isSelectedForTemplate ? 'selected-for-template' : ''].filter(Boolean).join(' ');
        const numberClasses = ['date-number', isToday ? 'today' : '', !isToday && isSunday ? 'sunday' : '', !isToday && isSaturday ? 'saturday' : ''].filter(Boolean).join(' ');

        const labelsForDate = labels.filter(label => label.date === dateStr);
        let labelsHtml = labelsForDate.map(label => {
            const isEditing = activeLabelInfo?.type === 'existing' && activeLabelInfo.id === label.id;
            const isBeingMoved = moveInfo?.labelId === label.id;
            const classes = `label ${isEditing ? 'editing' : ''} ${isBeingMoved ? 'is-being-moved' : ''}`;
            const style = getLabelStyle(label.style);
            return `
            <div class="${classes}"
                 contenteditable="${isEditing}"
                 data-id="${label.id}"
                 style="top: ${label.top}px; left: ${label.left}px; ${style}"
            >${label.text}</div>
            `;
        }).join('');
        
        if (activeLabelInfo?.type === 'new' && activeLabelInfo.date === dateStr) {
            const style = getLabelStyle(activeLabelInfo.style);
            labelsHtml += `
            <div class="label editing"
                 id="temp-new-label"
                 contenteditable="true"
                 style="top: ${activeLabelInfo.top}px; left: ${activeLabelInfo.left}px; ${style}"
            >${activeLabelInfo.text}</div>
            `;
        }

        return `
          <div class="${cellClasses}" data-date="${dateStr}">
            <div class="${numberClasses}">${date.getDate()}</div>
            <div class="labels-container">${labelsHtml}</div>
          </div>
        `;
      }).join('');
      
      const isMobile = window.innerWidth <= 768;

      const appHtml = `
        <div class="app-container">
          <header class="header">
            <div class="header-top">
                <div class="header-title-bar">
                    <h1 class="header-title">
                        <span id="year-month-selector" class="year-month-selector" title="年月を変更">
                        ${year}年 ${month + 1}月
                        </span>
                    </h1>
                    <div id="id-control-container" class="id-control">
                        <input type="text" id="calendar-id" placeholder="スケジュール名を入力" ${isMobile ? 'readonly' : ''}>
                    </div>
                </div>
                <div class="data-ops">
                    <button id="new-btn" data-action="new">新規</button>
                    <button id="save-btn" data-action="save-json">保存</button>
                    <button id="import-btn" data-action="import">読込</button>
                </div>
            </div>
            <div class="decoration-bar">
              <div class="deco-control">
                <label for="text-color-picker">文字色</label>
                <input type="color" id="text-color-picker" data-style="color" data-css-prop="color">
              </div>
              <div class="deco-control">
                <label for="label-color-picker">ラベル色</label>
                <input type="color" id="label-color-picker" data-style="backgroundColor" data-css-prop="backgroundColor">
              </div>
              <div class="deco-control">
                <label for="font-size-slider">文字大きさ</label>
                <input type="range" id="font-size-slider" min="10" max="24" step="1" data-style="fontSize" data-css-prop="fontSize">
                <span id="font-size-value" class="font-size-value">13</span>
              </div>
              <div class="deco-control style-btn-group">
                <button id="bold-btn" data-style="fontWeight" data-css-prop="fontWeight"><b>B</b></button>
                <button id="italic-btn" data-style="fontStyle" data-css-prop="fontStyle"><i>I</i></button>
              </div>
            </div>
          </header>
          <main class="calendar-board" aria-label="カレンダー">
            <div class="calendar-grid" id="calendar-grid">
              ${dayHeadersHtml}
              ${dateCellsHtml}
            </div>
          </main>
        </div>
      `;

      root.innerHTML = appHtml;

      // --- イベントリスナーの登録 ---
      document.getElementById('year-month-selector').addEventListener('click', (e) => {
        e.stopPropagation();
        if (popover.style.display !== 'none' && popover.querySelector('.year-month-popover-content')) {
            hidePopover();
        } else {
            showPopover(e.currentTarget, 'yearMonth');
        }
      });
      
      // PC用ボタン
      const dataOpsContainer = document.querySelector('.data-ops');
      if (dataOpsContainer) {
          dataOpsContainer.addEventListener('click', (e) => {
              const action = e.target.dataset.action;
              if (action === 'new') handleNew();
              if (action === 'save-json') handleSave();
              if (action === 'import') handleImport();
          });
      }

      // Mobile用ポップオーバートリガー
      const idControlContainer = document.getElementById('id-control-container');
      idControlContainer.addEventListener('click', (e) => {
        if (window.innerWidth > 768) return;
        const idInput = document.getElementById('calendar-id');
        // 入力モードの時はポップオーバーを出さない
        if (idInput && !idInput.readOnly) {
          return;
        }
        e.stopPropagation();
        showPopover(idControlContainer, 'dataOps');
      });
      
      const idInput = document.getElementById('calendar-id');
      idInput.value = currentId;
      idInput.addEventListener('input', e => {
        currentId = e.target.value;
      });

      const calendarGrid = document.getElementById('calendar-grid');
      calendarGrid.addEventListener('click', handleCalendarClick);
      calendarGrid.addEventListener('dblclick', handleCalendarDblClick);
      calendarGrid.addEventListener('mousedown', handleDragStart);

      popover.addEventListener('click', handlePopoverAction);
      
      document.removeEventListener('click', handleDocumentClick);
      document.addEventListener('click', handleDocumentClick);

      const decoBar = document.querySelector('.decoration-bar');
      if (decoBar) { // スマホでは存在しないのでnullチェック
        decoBar.addEventListener('input', handleDecorationChange);
        decoBar.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', handleDecorationChange);
        });
        updateDecorationBar();
      }
    };

    // --- 初期化 ---
    const initialize = () => {
        loadLabelsFromLocalStorage();
        loadTemplatesFromLocalStorage();
        render();
    };
    
    initialize();
  </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>